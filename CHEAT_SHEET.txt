╔════════════════════════════════════════════════════════════════════════════════╗
║                      C EMBEDDED SYSTEMS - QUICK CHEAT SHEET                   ║
║                         For Quick Reference During Learning                   ║
╚════════════════════════════════════════════════════════════════════════════════╝

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. INCLUDE HEADERS (at top of file)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#include <stdio.h>      // Input/Output (printf, scanf)
#include <stdint.h>     // Fixed-width types (uint8_t, int16_t, etc.)
#include <stdbool.h>    // Boolean type
#include <string.h>     // String operations
#include <math.h>       // Math functions (compile with -lm)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. FIXED-WIDTH DATA TYPES (Essential for Embedded!)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

uint8_t    0 to 255                  (1 byte) - ADC readings, flags
int8_t     -128 to 127               (1 byte) - Small signed values
uint16_t   0 to 65,535               (2 bytes) - Sensor readings
int16_t    -32,768 to 32,767         (2 bytes) - Temperature, altitude
uint32_t   0 to 4,294,967,295        (4 bytes) - Timestamps, registers
int32_t    -2B to +2B                (4 bytes) - Large numbers
float      -3.4E+38 to +3.4E+38      (4 bytes) - Decimals (be careful in ISR)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. POINTERS (Critical for Hardware Access!)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

int x = 10;
int *ptr = &x;              // Get address (&x)
printf("%d", *ptr);         // Dereference (*ptr) → 10
ptr++;                       // Move to next memory location

// Hardware register access:
#define PORT_A ((uint32_t *)0x40020000)  // Register at this address
*PORT_A = 0xFF;             // Write to register
uint32_t value = *PORT_A;   // Read from register

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. ARRAYS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

uint16_t sensor_buffer[10];           // 10-element array
sensor_buffer[0] = 100;               // First element
uint16_t *ptr = sensor_buffer;        // Array = pointer to first element
sensor_buffer[i];                     // Access via index
*(ptr + i);                          // Access via pointer arithmetic

// Multi-dimensional:
uint8_t matrix[3][4];                // 3x4 matrix
matrix[0][1] = 5;                    // Row 0, Column 1

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. STRUCTS (Organize Related Data)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

typedef struct {
    uint16_t x;
    uint16_t y;
    uint8_t status;
} Position;

Position drone_pos = {100, 200, 0};       // Initialize
drone_pos.x = 150;                        // Access member
Position *ptr = &drone_pos;               // Pointer to struct
ptr->x = 150;                             // Via pointer

// Array of structs:
Position positions[10];                   // 10 position records
positions[0].x = 100;

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. BIT MANIPULATION (Hardware Registers!)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

uint8_t flags = 0;

// SET bit 3:
flags |= (1 << 3);

// CLEAR bit 3:
flags &= ~(1 << 3);

// CHECK bit 3:
if (flags & (1 << 3)) { /* bit is set */ }

// TOGGLE bit 3:
flags ^= (1 << 3);

// Example: Status register (8 bits)
// Bit 0: Motor ON/OFF
// Bit 1: Sensor Ready
// Bit 2: Error Flag

#define MOTOR_BIT      0
#define SENSOR_BIT     1
#define ERROR_BIT      2

flags |= (1 << MOTOR_BIT);     // Turn motor ON
if (flags & (1 << ERROR_BIT))  // Check for error
    flags &= ~(1 << MOTOR_BIT); // Turn motor OFF

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. FUNCTIONS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Declaration:
int add(int a, int b);                 // Prototype

// Definition:
int add(int a, int b) {
    return a + b;
}

// Pass by value (copy):
void set_speed(int speed) { ... }

// Pass by reference (pointer):
void init_sensor(uint16_t *data) {
    *data = 0;  // Modify original
}

// Return pointer:
int* get_buffer() { static int buf[10]; return buf; }

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. CONTROL FLOW
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// IF:
if (temperature > 50) {
    printf("Too hot!\n");
} else if (temperature < 0) {
    printf("Too cold!\n");
} else {
    printf("OK\n");
}

// FOR LOOP:
for (int i = 0; i < 10; i++) {
    printf("%d ", i);
}

// WHILE LOOP:
while (battery_voltage > 3.0) {
    update_sensors();
}

// SWITCH:
switch (drone_state) {
    case STATE_IDLE:
        printf("Idle\n");
        break;
    case STATE_FLYING:
        printf("Flying\n");
        break;
    default:
        printf("Unknown\n");
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. INPUT/OUTPUT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

printf("Value: %d\n", value);         // Print integer
printf("Float: %.2f\n", 3.14159);    // Print float with 2 decimals
printf("Hex: 0x%X\n", 255);          // Print as hexadecimal
printf("Char: %c\n", 'A');           // Print character

scanf("%d", &value);                  // Read integer from keyboard
scanf("%f", &float_value);            // Read float

// File operations:
FILE *file = fopen("data.txt", "w");  // Open for writing
fprintf(file, "%d\n", value);         // Write to file
fclose(file);                          // Close file

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. COMMON PRINTF FORMAT SPECIFIERS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

%d or %i     Decimal integer
%u           Unsigned integer
%x           Hexadecimal (lowercase)
%X           Hexadecimal (uppercase)
%b           Binary (non-standard, use %d with bit-shifting)
%f           Float/double
%.2f         Float with 2 decimal places
%c           Character
%s           String
%p           Pointer address (as hex)

Example:
uint16_t voltage = 3300;  // 3.3V in mV
printf("Voltage: %u mV = %.2f V\n", voltage, voltage/1000.0);
// Output: Voltage: 3300 mV = 3.30 V

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
11. OPERATORS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Arithmetic:     +  -  *  /  %
Comparison:     ==  !=  <  >  <=  >=
Logical:        &&  ||  !
Bitwise:        &  |  ^  ~  <<  >>
Assignment:     =  +=  -=  *=  /=  |=  &=  ^=  <<=  >>=
Ternary:        condition ? true_value : false_value
Increment:      ++  --

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
12. COMMON PATTERNS IN EMBEDDED CODE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PATTERN: Circular Buffer (for logs)
uint16_t buffer[256];
uint8_t buffer_index = 0;
buffer[buffer_index++ & 0xFF] = data;  // Auto-wrap at 256

PATTERN: Bounded Variable (PWM speed 0-100)
if (speed > 100) speed = 100;
if (speed < 0) speed = 0;

PATTERN: Timeout Handler
uint32_t start_time = get_ms();
while (!complete && (get_ms() - start_time) < TIMEOUT_MS) {
    do_work();
}

PATTERN: Checksum
uint8_t checksum = 0;
for (int i = 0; i < length; i++) {
    checksum += data[i];
}

PATTERN: Simple Low-Pass Filter
filtered = 0.7 * raw + 0.3 * previous;

PATTERN: Rate Limiting (run every Nth cycle)
static uint8_t counter = 0;
if (++counter >= 10) {
    counter = 0;
    slow_task();  // Runs 1/10 as often
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
13. MAIN STRUCTURE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#include <stdio.h>
#include <stdint.h>

// Global defines
#define MAX_SPEED 100

// Global variables (use sparingly)
uint8_t system_state = 0;

// Function prototypes
void init_system(void);
void main_loop(void);

// Main function
int main(void) {
    init_system();
    
    while (1) {
        main_loop();
    }
    
    return 0;
}

// Function implementations
void init_system(void) {
    printf("System initializing...\n");
}

void main_loop(void) {
    // Run continuously
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
14. COMPILATION COMMANDS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Basic:
$ gcc -o output_name input_name.c

With all warnings:
$ gcc -Wall -Wextra -o output_name input_name.c

With debugging symbols:
$ gcc -g -o output_name input_name.c

With optimization:
$ gcc -O2 -o output_name input_name.c

With math library:
$ gcc -o output_name input_name.c -lm

Run:
$ ./output_name

Debug with gdb:
$ gdb ./output_name
(gdb) break main
(gdb) run
(gdb) next
(gdb) print variable_name

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
15. MEMORY LAYOUT (Important to Understand!)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Memory Address:
┌─────────────────────────┐ 0xFFFFFFFF (top)
│  Stack (grows down)     │ ← Local variables, function params
├─────────────────────────┤
│  (empty)                │
├─────────────────────────┤
│  Heap (grows up)        │ ← malloc(), free()
├─────────────────────────┤
│  Uninitialized Data     │ ← Static variables (not init)
├─────────────────────────┤
│  Initialized Data       │ ← Static variables (init), constants
├─────────────────────────┤
│  Code (read-only)       │ ← Program instructions
└─────────────────────────┘ 0x00000000 (bottom)

Stack variables:    int x = 10;      (automatic cleanup)
Heap variables:     int *p = malloc(sizeof(int));  (manual cleanup)
Static variables:   static int x = 0;  (persistent)
